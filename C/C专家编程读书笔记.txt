摘自：C专家编程

		第2章 这不是BUG,而是语言特性
1、一个L的NUL用于结束一个ACSII字符串，两个L的NULL用于表示什么也不指向(空指针)。

2、符号重载
static:	在函数内部，表示该变量的值在各个调用间一直保持延续性；在函数这一级，表示该函数或全局变量只对本文件可见。
extern:用于函数定义，表示全局可见(默认)；用于变量，表示它在其他地方定义。
void:作为函数返回类型，表示不返回任何值；在指针声明中，表示通用指针的类型；位于参数列表中，表示没有参数。
* :乘法运算符；用于指针，间接引用；在声明中，表示指针。

		第3章 分析C语言声明
1、联合一般被用来节省空间，因为有些数据项是不可能同时出现的，如果同时存储它们，就会浪费存储空间。

2、C语言声明的优先级规则
   A 声明从它的名字开始读取，然后按照优先级顺序依次读取
   B 优先级从高到低依次是：
	B.1 声明中被括号括起来的那部分
	B.2 后缀操作符：括号()表示这是一个函数，而方括号[]表示这是一个数组。
	B.3 前缀操作符：星号*表示"指向....的指针"
   C 如果const和volatile关键字的后面紧跟类型说明符(如int,char)，那么它作用于类型说明符，其他情况下，这两个关键字作用于它左边紧邻的指针信号。
 例：char * const *(*next)(); next是一个指针，它指向一个函数，该函数返回另一个指针，该指针指向一个类型为char的常量指针。

3、typedef是一种声明形式：它为一种类型引入新的名字、而不是为变量分配空间，应该用在：
	数组、结构、指针以及函数的组合类型
	可移植类型

		第 4 章 数组和指针并不相同
1、在C语言中，对象必须有且只有一个定义，但它可以多个extern声明。
2、式子：X = Y;符号X的含义是X所代表的地址，称为左值，左值在编译时可知；符号Y的含义是Y所代表的地址内容，被称为右值，右值知道运行时才知道。
3、在C语言中，"可修改的左值"这个术语是为了与数组名区分，数组名是个左值但不是可修改的左值。
4、extern char a[] 与extern char a[100]等价的原因：两个声明都提示a是一个数组（即内存地址），数组内的字符可以从这个地址找到。编译器并不需要知道数组总共多长，只产生偏离起始地址的偏移地址。从数组提取一个字符，只要简单的从符号表显示的a地址加上下标，需要的字符就位于这个地址中。
5、数组与指针的访问
1）数组的访问：char a[9]="abcdefg", c=a[i]; 假设编译器符号表具有一个地址9980.运行时步骤1：取i 的值，将它与9980相加；运行步骤2：取地址（9980+i）的内容。
2）指针的访问：char *p,c=*p;假设编译器符号表有一个符号p，它的地址为4624。运行时步骤1：取地址4624的内容，假设为"5081"；运行时步骤2：取地址5081的内容
3）定义为指针，但以数组方式引用：char *p="abcdefgh", c=p[i];假设编译器符号表具有一个p，地址为4624.运行时步骤1：取地址4624的内容，假设为5081；运行时步骤2：取得i值，并将它与5081相加；运行步骤3：取地址（5081+i）的内容。
6、被声明extern char *p,而原先的定义是char p[10].对于这种情形，当用P[i]提取声明的内容时，得到的是一个字符，而用上面这种方法，编译器把它当成一个指针，字符被解释为地址。
7、数组与指针的区别：
1）指针：保存数据的地址；数组：保存数据
2）指针：间接访问数据；数组：直接访问数据
3）指针：通常用于动态数据结构；数组：通常用于存储固定数据且数据类型相同的元素
4）指针：相关的函数为malloc(),free()；数组：隐式分配和删除
5）指针：通常指向匿名数据；数组：自身即为数据名
8、定义指针时，编译器并不为指针所指向的对象分配空间，只是分配指针本身的空间；初始化指针时所创建的字符串常量被定义为只读，不可修改其值；由字符串常量初始化的数组时可以修改的。

		第9章 再论数组(数组和指针相同的情况)
1、数组声明的3种情况
(1)外部数组声明
(2)数组定义(定义是声明的以一种特殊情况，它分配内存空间，并可能提供一个初始值)
(3)函数参数的声明，所以作为函数参数的数组总是可以通过编译器转换为指针。
数组的声明就是数组，指针的声明就是指针，不可混淆。但在使用数组时数组总可以写成指针的形式。

2、数组和指针相同的情况
(1)表达式中的数组名被编译器当做一个指向数组第一个元素的指针
(2)下标总是与指针的偏移量相同
(3)在函数参数的声明中，数组名被编译器当做一个指向数组第一个元素的指针

3、在函数参数传递时，没有办法把数组本身传递给一个函数，它总是被自动转换为指向数组的指针，在函数内部使用指针对数组的操作跟传递数组本身没有区别，但是用sizeof来获得数组长度结果不正确。

4、数组和指针可交换性总结
(1)用a[i]这样的形式对数组进行访问总是被编译器解释为像*(a+i)这样的指针访问
(2)指针始终是指针，它绝不可以改写成数组
(3)在特定的上下文中，作为函数的参数，一个数组声明可以看作是一个指针，作为函数参数的数组始终会被编译器修改成为指向数组第一个元素的指针
(4)当吧一个数组定义为函数的参数时，可以选择把它定义为数组，也可以定义为指针，但在函数内部事实上获得的都是一个指针
(5)定义和声明必须匹配，如果定义一个数组，在其他文件对它进行声明时也必须声明为数组，指针也是如此

5、多维数组
(1)在表达式中，数组名被编译器当作"指向数组第一个元素的指针"。不能把数组赋给另外一个数组，但可以把数组名赋给一个指针。
(2)在C语言的多维数组中，最右边的下标是最先变化的，这个约定被称为"行主序"。
(3)只有字符串常量才可以初始化指针数组。


		第10章 再论指针
1、数组的数组与指针数组的访问
1)一个数组的数组:char a[4][6]，a的地址为9980，取a[i][j]的值
  (1)步骤1：取i的值，把它的长度调整为一行的宽度(这里是6)，然后加到9980上
  (2)步骤2：取j的值，把它的长度调整为一个元素的宽度(这里是1)，然后加到前面所得出的结果上。
  (3)步骤3：从地址(9980 + i*scale1 + j*scale2)中取出内容
2)一个字符串指针数组: char *p[4],p的地址为4624,取p[i][j]的值
  (1)步骤1：取i的值，乘以指针的段度(四个字节),并把结果加到4624上
  (2)从地址(4624+4*i)取出内容，假设为"5081"
  (3)取j的值，乘以元素的宽度(这里1个字节)，并把结果加到5081上
  (4)从地址(5081 +j*1)取出内容

2、锯齿状数组(字符串指针数组)，即第二维长度未知，为了节约资源，一种方法就是使用字符串指针数组来指向第二维。

3、只要有可能，尽量不要选择拷贝整个字符串的方法，如果需要从两个不同的数据结构访问它，拷贝一个指针比拷贝整个数组快得多，空间也节省很多。

3、数组与指针参数
		实参			匹配的形式参数
数组的数组	char [8][10]；		char (*)[10]；	数组指针
指针数组	char *c[15];		char **c;	指针的指针
数组指针	char (*c)[64];		char (*c)[64];	不变
指针的指针	char **c		char **c	不变
   在main()函数中看到char **argv这样的参数，是因为argv是个指针数组(即char *argv[])。

4、向函数传递一个一维数组
   任何一维数组均可作为函数的实参，形参被改写为指向数组第一个元素的指针，所以需要一个约定来提示数组的长度，一般有两个基本方法：
(1)增加一个额外的参数，表示元素的数目
(2)赋予数组最后一个元素一个特殊的值，提示它是数组的尾部(例如字符串结尾'\0')。

5、使用指针向函数传递一个多维数组
(1)方法一:my_function(int my_array[10][20])
(2)方法二：my_function(int(*my_array)[20]);参数列表中(*my_array)周围的括号是绝对需要的，这样可以确保它被翻译为一个指向20个元素的int数组的指针，而不是一个20个int指针元素的数组。
(3)方法三:my_function(char **argv);允许任意的字符串指针数组传递给函数，但必须是指针数组，而且必须是指向字符串的指针数组。

6、使用指针从函数返回一个数组
	严格的说，无法直接从函数返回一个数组，但可以让函数返回一个指向任何数据结构的指针，当然也可以是一个指向数组的指针。

		第11章 懂得C，C++不在话下
1、抽象――取事物的本质特性
   面向对象编程从面向对象设计开始，面向对象设计从抽象开始。
2、封装――把相关的类型、数据和函数组合在一起
   把抽象数据类型和它们的操作捆绑在一起的时候，就是进行"封装"
3、继承――复用已经定义的操作
   当一个类沿用或定制它的唯一基类的数据结构和成员函数时，它就是使用单继承。
4、多重继承――从两个或更多的基类派生
5、重载――作用于不同类型的统一操作具有相同的名字
6、多态――运行时绑定
   多态：指一个函数或操作符只有一个名字，但它可以用于几个不同的派生类型的能力，每个对象都实现该操作的一种变型，表现一种最适合自身的行为。

		附录A 程序员工作面试的秘密
1、怎样才能检测到链表中存在循环
(1)无限制
   答案一：对访问过的每个元素作个标记，继续遍历这个链表，如果遇到某个已经做过的标记元素，说明链表存在循环。
(2)限制一：这个链表位于只读内存区域，无法再元素上作标记
   答案二：当访问每个元素时，把它存储在一个数组中。检查每一个后继的元素，看看他是否已经存在于数组中。
(3)限制二：内存空间非常有限，无法创建一个足够长的数组。然而，可以假定如果链表中存在循环，它出现在前N个元素之中
   答案三：设置一个指针，指向链表的头部。在接下去对直到第N个元素的访问中，把N-1个元素依次同指针指向的元素进行比较。然后指针移向第二个元素，把它与后面N-2个元素进行比较，依次类推。如果出现比较相等的情况就说明前N个元素中存在循环，否则没有。
(4)限制三：链表的长度是任意的，而且循环可能出现在任何位置
   答案四：排除一种特殊情况，就是3个元素的链表中第2个元素的后面是第1个元素。设置两个指针P1和P2，P1指向第一个元素，P2指向第三个元素，看它们是否相等。若相等就属于特殊情况。如果不等，把P1向后移一个元素，P2向后移两个元素。检查两个指针的值，如果相等，说明链表中存在循环。如果不等，继续按照前述方法进行，如果出现两个指针都是NULL得情况，说明链表中不存在循环。因为如果存在循环，这种方法肯定能检测出来，因为其中一个指针肯定能够追上另一个指针。

2、C语言中不同的增值语句的区别何在
   X= X+1;	++X;	X++;	X+=1;
这四条语句的功能是相等的，都是把X的值增加1。如果不考虑上下文环境，它们之间并没有什么区别。++X：先增加X的值，然后再在周围的表达式中使用X的值；另一种解释：取X的地址，增加它的内容，然后把值放入寄存器中。X++：先在周围的表达式中使用X的值，然后再增加X的值；另一种解释：取X的地址，把它的值装入寄存器中，然后增加内存中的X的值。

3、库函数调用和系统调用区别何在
   简单的说：库函数调用是语言或应用程序的一部分，系统调用是操作系统过的一部分。
(1)在所有的ANSI C编译器版本中，C函数库是相同的；它调用函数库中的一个程序；与用户程序相联系；在用户地址空间执行；它的运行时间属于"用户"时间；属于过程调用，开销较小。
(2)各个操作系统的系统调用是不同的；它调用系统内核的服务；是操作系统的一个进入点；在内核地址空间进行，它的运行时间属于"系统"时间；需要在切换到内核上下文环境然后切换回来，开销比较大。
   库函数调用通常比行内展开的代码慢，因为它需要付出函数调用的开销，但系统调用比库函数调用还要慢很多，因为它需要把上下文环境切换到内核模式。

4、文件描述符与文件指针有何不同
文件描述符就是开放文件的每个进程表的一个偏移量，它用于UNIX系统调用中，用于标识文件。
FILE指针保存了一个FILE结构的地址。FILE结构用于表示开放的I/O流，它用于ANSIC标准I/O库调用中，用于标识文件。

5、确定一个数是有符号还是无符号数
不能错误的把“有符号数”通“具有负号”等同起来。无符号的本质特征是它永远不会是负的，有符号数的本质特征是对最左边一个位取补将会改变它的符号。

6、从文件中随机提取一个字符串
(1)方法一：读取文件，对字符串进行计数，并记录每个字符串的偏移位置，然后，在1和字符串总数之间取一个随机数，根据选中字符串的偏移位置取出该字符串。
(2)方法二：条件：只能按顺序遍历文件一次，并且不能使用表格来存储所以字符串的偏移位置。
基本技巧是在幸存的字符串挑选，并在过程中不断更新。在其中每一步，读入字符串N，在它(按照概率1/N)和前一个幸存的字符串(按照(N-1)/N的概率)之间进行选择，当到达文件末尾的时候，最后一个幸存的字符串就是从整个文件中随机提取的那个字符。
