摘自<C和指针>
	
			第1章 快速上手

			第2章 基本概念
2.1 环境
    在ANSI C的任何一种实现中，存在两种环境：翻译环境和执行环境。翻译环境:源代码被转换成可执行的机器指令，执行环境:用于实际执行代码。
1、翻译
    翻译由几个步骤组成，组成一个程序的每个源文件通过编译过程分别转换成目标代码，然后各个目标文件有连接器捆绑在一起，形成一个单一而完整的可执行程序。
    编译过程本身也由几个阶段组成，首先是预处理器在源代码上执行一些文本操作，然后源代码经过解析(产生绝大多数错误和警告)，接着产生目标代码(如果有优化选项，优化器就会对目标代码进行优化)。
2、执行
    程序的执行过程也经历几个阶段。首先，程序必须载入到内存中；在宿主环境(操作系统)，这个任务有操作系统完成，在独立环境中，载入手工安排或者把可执行代码置入只读内存(ROM)来完成。然后，程序的执行便开始；在绝大多数机器里，程序使用一个运行时堆栈(它用于存储函数的局部变量和返回地址)，也可以使用静态内存(存储于内存中的变量在程序的整个执行过程中将一直保留他们的值)。
2.2 词法规则

			第3章 数据
3.1 基本数据类型
    在C语言中，仅有4种基本数据类型：整型、浮点型、指针，聚合类型(数组和结构等)。
1、整型家族
    整型包括字符、短整型、整型和长整型，它们都分为有符号和无符号。长整型至少应该和整型一样长，而整型至少应该和短整型一样长。
(1)整型字面值：字面值常量的缩写
    在整数数字面值后面添加字符L或l，可以使这个整数被解释为long整形值，字符U或u则用于把数值制定为unsigned整型值。在缺省情况下，字面值的类型就是上述类型中最短但足以容纳整个值的类型。
    浮点数字面值在缺省情况下都是double类型，除非它的后面跟一个l或L表示它是一个long double类型的值，或者跟一个f或F表示它是一个float类型的值。
(2)枚举类型
    枚举类型就是指它的值为符号常量而不是字面值的类型。符号名被当作整型常量处理，声明为枚举类型的变量实际上是整数类型。
2、浮点型
    浮点型家族包括float、double和long double类型。
3、指针
(1)指针常量
(2)字符串常量：C语言存在字符串的概念：它就是一串以NUL字节结尾的零个或多个字符。
3.2 基本声明
1、声明指针
2、隐式声明
    C语言中有几种声明，它的类型名可以省略。例如函数不显式的声明返回值的类型，它默认返回整型。
3、常量
    使用const关键字来声明常量。让常量拥有值的两种方法：一是在声明是对它进行初始化，二是在函数中声明为const的形象在函数被调用时会得到实参的值。如果变量的值不会被修改，应当在声明中使用const关键字。
    #define是另外一种创建名字常量的机制
3.5 作用域
    当变量在程序的某个部分被声明时，它只有在程序的一定区域才能被访问。这意味着两点：一是其他函数无法通过这些变量的名字访问它们，二是只要分属不同的作用域，可以给不同变量同一个名字。
3.6 链接属性
    标识符的链接属性决定如何处理在不同文件中出现的标示符。链接属性一共有3种：external（外部）,internal（内部）,none（无）。
    关键字extern和static用于在声明中修改标识的链接属性，在它前面加上static关键字可以使它的链接属性变为internal。
3.7 存储类型
    变量的存储类型是指存储变量值的内存类型，有三个地方可以用于存储变量：普通内存，运行时堆栈，硬件寄存器。
(1)静态变量：在任何代码块之外声明的变量总是存储于静态内存中，也就是不属于堆栈内存
    静态变量在程序运行之前创建，在程序的整个执行期间始终存在，保持原先的值，除非给它赋一个不同的值或者程序结束。
(2)自动变量：在代码块内部声明的变量的缺省存储类型是自动的，存储于对堆栈中
    在程序执行到声明自动变量的代码块时，自动变量才被创建，当程序的执行流离开该代码时，这些自动变量便自行销毁。
    对于在代码块内部声明的变量，如果给它加上关键字static，可以使它的存储类型从自动变为静态。修改变量的存储类型并不代码修改该变量的作用域，它仍然只能在该代码块内部按名字访问。函数的形式参数不能声明为静态，因为实参总是在堆栈中传递给函数，用于支持递归。
(3)寄存器变量：关键字register可以用于自动变量的声明，提示它们应该存储于机器的硬件寄存器而不是内存中。
3.8 static关键字
    当它用于函数定义时，或用于代码块之外的变量声明时，static关键字用于修改标示符的链接属性，从external改为internal，但标示符的存储类型和作用域不受影响，用这种方式声明的函数或变量只能在声明它们的源文件中访问。
    当它用于代码块内的变量声明时，static关键字用于修改变量的存储类型，从自动变量修改为静态变量，但变量的链接属性和作用域不受影响。
    如果一个变量声明于代码内部，在它前面添加external关键字将使它所引用的是全局变量而非局部变量。

			第4章 语句
1.break和continue语句
    break语句终止循环。在执行完break语句之后，执行流下一条语句就是循环正常结束后应该执行的语句。
    continue语句终止当前的那次循环。在执行完continue语句之后，执行流接下来就是重新测试表达式的值，决定是否继续执行循环。
    这两条语句的任何一条如果出现于嵌套的循环内部，它只是对最内层的循环起作用，无法使用break或continue语句影响外层循环的执行。
2.switch语句
    在switch语句内，continue语句没有任何效果。 
    如果表达式的值与所有case标签的值都不匹配，则所有语句被跳过，程序并不终止，也不会提示错误。default子句可以放在语句列表的任何位置，但一个switch语句只能一个default。

			第5章 操作符和表达式
1.移位
    在左移位中，值最左边的几位被丢弃，右移多出来的几个空位右0补齐。
    在右移位中存在一个左移位操作不曾面临的问题：从左边移入新位时，可以选择两种方案。一种是逻辑移位，左边移入的位用0填充；另一种是算术移位，左边移入的位由原先值的符号为决定。
    标准说明无符号值执行的所有移位操作都是逻辑移位，但对于有符号值，到底是采用逻辑移位还是算术移位取决于编译器。

			第6章 指针


			第7章 函数
1.函数的参数
    C函数的所有参数均以"传值调用"方式进行传递，这意味着函数将获得参数值的一份拷贝，这样函数可以放行修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。
    C的规则很简单：所有参数都是传值调用
    如果被传递的参数是一个数组名，并且在函数中使用下标引用该数组的参数，那么在函数中对数组元素进行修改实际上修改的是调用程序中的数组元素，这个行为被称为"传址调用"。
    数组参数的这种行为似乎与传值调用规则相悖，但其实并无矛盾之处。数组名的值实际是一个指针，传递给函数的就是这个指针的一份拷贝，但在这份拷贝上执行间接访问操作所访问的是原先的数组。

2.ADT和黑盒
    C可以用于设计和实现ADT抽象数据类型。通过static关键字的合理使用实现限制函数和数据定义的作用域，限制对那些并非接口的函数和数据的访问。

3.递归函数
(1)追踪递归函数关键是理解函数中所声明的变量时如何存储的

4.可变参数列表

				第8章 数组
1.一维数组
1)数组名与指针
    数组具有一些和指针完全不同的特征，数组具有确定数量的元素，而指针只是一个标量(sizeof);只有数组名在表达式中使用时，编译器才会为它产生一个指针常量，注意不是指针变量，不能修改常量值。
    在两种场合下，数组名并不用指针常量来表示：当数组名最为sizeof操作符或单目操作符&的操作数时。
    声明一个数组时，编译器将根据声明所指定的元素数量为数组保留内存空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始位置。声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何对应类型值分配内存空间，而且指针变量并未被初始化为指向任何现有内存空间。

				第9章 字符串、字符和字节
1.复制字符串
    必须保证目标字符数组的空间足以容纳需要复制的字符串。如果字符串比数组长，多余的字符仍然被复制，它们将覆盖原先存储于数组后面的内存空间的值。

				第10章 结构和联合

1、作为函数参数的结构
    结构变量是一个标量，它可以用于其它标量可以使用的任何场合。尽量采用指针传递方案（按地址传递），而不是采用结构体传递方案（按值传递）。因为按结构体传递时是整个值的拷贝，而按指针传递时只是传递指针值而已，因此指针传递比按结构体传递效率更高。

				第11章 动态内存分配
1、malloc和free执行动态内存分配和释放
    malloc的参数就是需要分配的内存字节数，如果满足要求就返回指向被分配的内存块起始位置的指针；如果不满足，则返回NULL指针，因此，对返回值进行判断很重要。  
2、calloc和realloc
    calloc也用于分配内存，与malloc得区别是返回指向内存的指针之前把它初始化为0。
    realloc函数用于修改一个原先已经分配的内存块大小。

				第12章 使用结构和指针

				第13章 高级指针话题
1、函数指针
    函数指针最常见的两个用途是转换表和作为参数传递给另一个函数。
    回调函数：把函数指针作为参数传递给其他函数
2、命令行参数
3、字符串常量
    当一个字符串出项于表达式中时，它的值是个指针常量，编译器把这些制定字符的一份拷贝存储在内存的某个位置，并存储一个指向第1个字符的指针。
    "xyz"+1：指针值加上1，结果是指针，指向字符串中的第2个字符：y。

				第14章 预处理器
1、宏定义#define
   #define机制包括了一个规定，允许把参数替换到文本中。宏的声明方式如下：
   #define name(parameter-list) stuff 
   其中，parameter-list是一个有逗号分隔的符号列表，它们可能出现在stuff中。参数列表的左括号必须也name紧邻，如果有任何空白存在，参数列表就会被解释为stuff的一部分
2、宏与函数
   非常频繁的用于执行简单的计算时，宏比函数更胜一筹。因为调用和从函数返回的代码很可能比实际执行这个小型计算工作的代码更大；另一方面，函数的参数必须声明为一种特定的类型，所以它只能在类型合适的表达式上使用，而宏与类型无关。
3、带副作用的宏参数
4、命名约定
5、条件编译
   是否被定义：#if defined(symbol)和#ifdef symbol等价，#if !defined(symbol)和#ifndef symbol等价。   嵌套指令：为记住复杂的嵌套指令，为每个#endif加上一个注释标签是很有帮助的，标签内容就是#if后面的表达式，当#if和#endif之间的代码块非常长时，这做法尤为有用。/*expression*/
6、文件包含
   #include指令使另一个文件的内容被编译，一个头文件被包含到10个源文件中，它实际上被编译了10次。当头文件被包含时，位于头文件的所有内容都要被编译，意味着每个文件只应该包含一组函数或数据的声明。
   编译器支持两种不同类型的#include文件包含：函数库文件和本地文件。
   嵌套文件包含的一个不利之处在于它使得我们很难判断文件之间的真正依赖关系，另一个不利之处在于头文件可能会被多次包含。解决办法：使用条件编译多重包含的危险就被消除，当头文件第1次被包含时，它被正常处理，如果头文件被再次包含，通过条件编译时，所有内容被忽略。

					第15章 输入输出函数


					第16章 标准函数库
1、整型函数
    这组函数返回整型值，分为三类：算术、随机数、字符串转换。
