摘自：嵌入式软件编程指南
	
		C/C++语言struct深层探索

1、强制类型转换
(char *)&sendCommPacket,先取地址，再转化为char型指针。

2、struct的成员对齐之自然对界
(1)自然对齐即默认对齐方式，指按结构体的成员中size最大的成员对齐。
(2)指定对齐
(3)各个成员按照他们被声明的顺序在内村中顺序存储，第一个成员的地址和整个结构的地址相同

3、struct的成员对齐之指定对界
(1)使用伪指令#prama pack(n),编译器将按照n个字节对齐；
   使用伪指令#prama pack(),取消自定义字节对齐方式。
注：如果值得n大于结构体中最大成员的size，则其不起作用，仍然按照size最大的成员进行对界。
例如：
	#pragma pach(n)
	struct naturalalign
	{
	  char a;
	  int b;
	};
	#prama pack()

4、struct 编程注意事项
在C语言中，当结构体中存在指针型成员是，一定要注意采用赋值语句时是否将2个实例中的指针型成员指向了同一片内存。

		C++中extern "C" 含义深层探索

1、程序
	#ifdef __cplusplus
	extern "C" {
	#endif
	.....
	#ifdef __cplusplus
	}
	#endif

2、extern "C"包含双重含义，首先被它修饰的目标是"extern"的；其次，被它修饰的目标是"C"。
1)被extern "C"限定的函数或变量是extern类型
extern int a,仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。
2)被extern "C"限定的函数或变量是按照C语言方式编译和链接的。
void foo(int x, int y);
该函数被C编译器编译后再符号库中的名字为_foo,而C++编译器则会产生像_foo_int_int之类的名字。
extern "C" void foo(int x, inty)
则都为_foo。
3)extern "C"的惯用法
(1)C++中引用C语言中的函数和变量，在包含C语言头文件时，需要进行下列处理：
	extern "C"
	{
	#include "xxxx.h"
	}
而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言不支持extern "C"声明。
(2)在C中引用C++语言中的函数和变量时，C++的头文件需添加extern "C"，但是在C语言中不能直接引用声明了extern "C"的该头文件，应该仅将C文件中将C++中定义的extern "C"函数声明为extern类型。

		C语言高效编程的几招

1、以空间换时间
函数和宏函数的区别在于，宏函数占用了大量的空间，而函数占用了时间。
函数调用是要使用系统的栈来保存数据的，CPU也要在函数调用时保存和恢复当前的现场，进行压栈和弹栈操作，所以函数调用需要一些CPU时间。
2、数学方法解决问题
3、使用位操作，减少除法和取模的运算。
4、汇编嵌入，高效C语言编程的必杀技

		嵌入式程序员应该知道的几个基本问题

1、预处理器
1)#define SECONDS_PER_YEAR	(60*60*24*365)UL  UL表示无符号长整型，这个容易忽略, 告诉编译器这个数是一个长整数。
3)写一个"标准"宏MIN:#define MIN(A,B) ((A) <= (B) ?  (A) : (B)),注意用括号把参数括起来。
3)#error的目的：预处理时打印诊断信息，或者叫错误信息。

2、无限循环：while与for得区别
while在循环时需要判断()中的内容，而for不需要判断内容，所以可能更节约时间，但有些编译器已经优化，两者效果一样。

3、用变量a给出的几个定义
int a		一个整型数
int *a		一个指向整型数的指针
int **a		一个指向指针的指针，所指向的指针是一个整型数
int a[10]	一个有10个整型数的数组
int *a[10]	一个有10个指针的数组，该指针是指向一个整型数
int (*a)[10]	一个指向有10个整型数数组的指针
int (*a)(int)	一个指向函数的指针，该函数有一个整型参数并返回一个整型数
int (*a[10])(int)一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数

4、关键字static的三个明显作用
1)在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持其值不变，与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量，随着所在函数的被调用和退出而存在和消失。
2)在函数体外，一个被声明为静态的变量只能被该源文件函数访问，不能被其他文件访问，为本地全局变量
3)在函数体外，一个被声明为静态的函数只可被该源文件的其他函数调用，不能被其他文件调用。

5、关键字const含意：不是常数，而是一种只读
(1)作用
   给读代码的人传达非常有用的信息；合理的使用可以使编译器自然的保护那些不希望被改变的参数，防止其被无意的代码修改。
(2)可以对const对象进行初始化，但在初始化以后不能进行赋值
const int a 等价 int const a：a是一个常整型数
const int *a：指向常整型数的指针（整型数是不可修改，指针可以）
int *const a：指向整型数的常指针（指针指向的整型数可以修改，但指针不可修改）
int const *a const：指向常整型数的常指针（都不能改）

6、关键字volatile
一个定义为volatile的变量是说这个变量可能会被意想不到的改变，这样编译器就不会去假设这个变量的值了。防止编译器的优化。
可用于如下几种情况：
(1)并行设备的硬件寄存器
(2)一个中断服务子程序中会访问到的非自动变量(全局变量)
(3)多线程应用中被几个任务共享的变量

7、绝对地址编程
int *addr; addr = (int *)0x10001; *addr = 0xff;

8、当表达式中存在有符号数类型和无符号类型时所有的操作数自动转化为无符号数。

9、中断特点
(1)中断不能返回一个值
(2)不能传递参数
(3)在许多的处理器/编译器中，浮点数一般都是不可重入的。一般不再中断中做浮点运算。
(4)printf经常有重入和性能上的问题，一般为不可重入。

10、评价下面的代码片段
unsigned int zero = 0;
unsigned int compzero = 0xffff;
对于一个int型不是16位的处理器来说，上面的代码是不正确的，应编写如下：
unsigned int compzero = ~0;

11、在嵌入式系统中，动态分配内存可能发生问题是什么
答案：内存碎片，碎片收集，变量的执行时间等等。函数malloc。

12、Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。
#define dPS struct s*
#typedef strcut s* tPS;
以上两种情况的意图都是要定义dPS和tPS最为一个指向结构s指针，哪种更好
答案：typedef更好。因为如下例子
dPS P1,P2;扩展struct s* p1,p2，p1为一个指向结构的指针，p2为一个实际的结构
tPS P3,P4;这个则定义了两个指针。

13、下面的结构是合法的吗，如果是做些什么？
int a= 5, b=7,c; c = a+++b;
这段代码完全合法，执行后结果c=12,a=6,b=7

		C语言嵌入式系统编程修炼

1、C语言模块化程序设计需理解概念
(1)模块即是一个.c文件和一个.h文件的结合，头文件(.h)中是对于该模块接口的声明
(2)某模块提供给其他模块调用的外部函数及数据需在.h中文件冠以extern关键字声明
(3)模块内的函数和全局变量需在.c文件冠以static关键字声明
(4)永远不要在.h文件中定义变量!定义变量和声明变量的区别在于定义会产生内存分配的操作，是汇编阶段的概念；而声明则只是告诉包含该声明的模块在连接阶段从其它模块寻找外部函数和变量。

2、一个嵌入式系统通常包含两类模块
1)硬件驱动模块，一个特定硬件对应一个模块
2)软件功能模块，其模块的划分应满足低偶合、高内聚的要求。

3、多任务与单任务
1)单任务：指该系统不能支持多任务并发操作，串行执行一个任务；多任务：『旯鄄⑿械耐时执行多个任务2)单任务程序典型架构：
(1)从CPU复位时的指定地址开始执行
(2)跳转至汇编代码startup处执行
(3)跳转至用户主程序main执行，在main中完成：初始化各个硬件设备，初始化各软件模块，进入死循环(无限循环)，调用各模块的处理函数

4、中断服务程序
1)中断服务程序需要满足如下要求
(1)不能返回值     (2)不能向ISR传递参数    (3)ISR应该尽可能短小精悍
(4)printf和浮点运算会带来重入和性能问题，不能在ISR中采用

5、硬件驱动模块
1)一个硬件驱动模块通常包括函数
(1)中断服务程序 ISR     (2)硬件初始化：设置硬件参数，将中断服务程序入口地址写入中断向量表
(3)设置CPU针对该硬件的控制线    (4)提供一系列针对该设备的操作接口函数

		内存操作

6、数据指针
1)在嵌入式系统中，多借助C语言指针所具有的对绝对地址单元内容读写能力来访问内存单元。以指针直接操作内存多发生在如下几种情况：
(1)某I/O芯片被定位在CPU的存储空间而非I/O空间，而且寄存器对应于某特定地址。
(2)两个CPU之间以双端口RAM通信，CPU需要在双端口RAM的特定单元书写内容以在对方CPU产生中断；
(3)读取在ROM或FLASH的特定单元所烧录的汉字或英文字模。

2)CPU以字节为单位编址，而C语言指针以指向的数据类型长度作自增和自减。

7、函数指针
(1)函数名直接对应于函数生成的指令代码在内存中的地址，因此函数名可以直接赋给指向函数的指针
(2)调用函数实际上等同于"跳转指令+参数传递处理+回归位置入栈"，将函数生成的目标代码首地址赋给CPU的PC寄存器。
(3)函数调用的本质是跳转到某一个地址单元的code去执行，所以可以"调用"一个根本不存在的函数实体。
注：函数无它，唯指令集合耳，你可以调用一个没有函数体的函数，本质上只是换了一个地址开始执行指令！

8、数组与动态申请
嵌入式系统的内存空间往往是十分有限的，申请动态内存，不经意的内存泄露会很快导致系统的崩溃。
(1)尽可能的选用数组，数组不能越界访问
(2)如果使用动态申请，则申请后一定要判断是否成功，并且malloc和free应成对出现。

9、使用宏定义是产生内嵌代码的唯一方法，是一种很好的代替函数方法。
(1)宏定义“像”函数，但不是函数，需要括上所有的“参数”
#define MIN(A,B)	((A)<(B) ? (A) : (B))
(2)可能产生副作用

10、寄存器变量：将变量存放在CPU的寄存器中，使用时不需要访问内存而直接从寄存器中读写，提高效率
(1)只有局部自动变量和形参才可以定义为寄存器变量，模块间全局变量、模块内全局变量、局部static变量，不能定义为寄存器变量
(2)register是一个"建议"型关键字，程序建议该变量放在寄存器中，实际不一定

11、内嵌汇编：主要使用在线汇编，即在C程序中直接插入_asm{}内嵌汇编语句

			屏幕操作

1、汉字处理
定义结构体和数组来存储汉字字模
typedef struct uincode_font16x16 
{
  int value; //内码
  char data[32]
}UnicodeStruct;

UnicodeStruct chinese[CHINESE_CHAR_NUM] = 
{
  {
   0xel34,
   {字模}
  }，
  {
   0xel35,
   {字模}  
  }
}

2、系统时间显示
    关于时间的显示，有一个效率问题。因为时间有其特殊性，60s才有一次分钟的变化，60分钟才有一次小时变化，如果每次读取时间在屏幕上完全重新刷新一次，浪费系统时间。 
    一个较好的办法是我们在时间显示函数中以静态变量分别存储小时，分钟，秒，只有内容发生变化的时候才更新其显示。

3、菜单操作
利用结构体，将菜单属性和操作“封装”在一起
typedef struct uincode_font16x16 
{
  char *text;
  int xPos;
  int yPos;
  void (*onOkFun)();
  void (*onCancelFun)();
}SysMenu, *SysMenuPtr;

SysMenu menu[MEMU_NUM] = 
{
  {
   "menu1", 0, 48, menu1OnOK,menu1OnCancel
  }，
  .....
}

			键盘操作

1、处理功能键
采用结构体STRUCT的方法
(1)将不同的画面类比WIN32中的不同的窗口，将窗口中的各种元素(菜单、按钮等)包含在窗口中
(2)给各个画面提供一个功能键"消息"处理函数，该函数接收按键信息为参数
(3)在各画面的功能键"消息"处理函数中，判断按键类型和当前焦点元素，并调用对应元素的按键处理函数
2、处理数字键
用户输入数字时是一位一位输入的，每一位的输入都对应着屏幕上的一个显示位置。用结构体将显示位置和数值捆绑在一起。
typedef struct
{
   char byNum;   //接收用户输入值
   int xPos;	//显示位置x坐标
   int yPos;	//显示位置y坐标
}InputNum, *InputNumPtr;

			性能优化

1、使用宏定义，宏是一种很好的代替函数的方法。
写一个"标准"宏MIN，这个宏输入两个参数并返回较小一个：
错误做法	#define MIN(A,B) (A<=B ? A: B)
正确做法	#define MIN(A,B) ((A) <= (B) ? (A) : (B))
宏需要知道的三点：
(1)宏定义"像"函数
(2)宏定义不是函数，因而需要括上所有"参数"
(3)宏定义可能产生副作用，不要给宏定义传入有副作用的"参数"，例如++，--这类。
2、使用寄存器变量
    这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，从而提高效率，变量说明符为register,对于循环次数较多的循环体控制变量及循环体内反复使用的变量均可定义为寄存器变量，而循环计数是应用寄存器变量的最好选择。
注意点：
(1)只有局部自动变量和形参才可以定义为寄存器变量。因为寄存器变量属于动态存储方式，凡需要采用静态存储方式的量都不能定义为寄存器变量，包括：模块间全局变量、模块内全局变量、局部static变量
(2)register是一个"建议"型关键字，只是建议该变量放在寄存器中，但最终该变量可能因为条件不满足并未成为寄存器变量，而是被放在存储器中。
例如：
int addition(int n)
{
  register i,s=0;
  for(i=1; i<n; i++)
  {
   s= s+ i;
  }
  return s;
}
3、内嵌汇编
   对时间要求苛刻的部分可以用内嵌汇编来重写，嵌入式C程序中主要使用在线汇编，即在C程序中直接插入
_asm{}内嵌汇编语句
4、硬件特性
CPU内部RAM > 外部同步RAM > 外部异步RAM > FALSH/ROM
5、活用位擦操作

			C/C++语言void及void指针深层次探索

1、void含义：字面意思"无类型"，void*则为"无类型指针"，void*可以指向任何类型的数据
真正发挥作用：(1)对函数返回的限定   (2)对函数参数的限定

2、使用规则
(1)如果函数没有返回值，则声明为void类型，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理
(2)如果函数无参数，则声明为void。在C语言中，可以给无参数的函数传递任意类型的参数
(3)小心使用void指针类型，不能对void指针进行算法操作。
(4)如果函数的参数可以是任意类型指针，那么应该声明其参数为void *。这样任何类型的指针都可以传入函数。
(5)void 不能代表一个真实的变量

			C/C++语言可变参数表深层探索（有难度）
1、支持可变参数:int printf(const char *format, ...)
在C/C++中，“...”表示可以接受不定数量的参数

			C/C++数组名与指针区别深层探索

1、数组名不是指针，指针长度一般为4，sizeof是一个操作符，而非一个函数。例如：sizefo(int)，它可以接受整数类型。

2、数组名本质
1)数组名的内涵在于其实体是一种数据结构
   char str[10],sizeof(str)为10(即占据内存大小：10字节)
2)数组名的外延在于可以转换为指向其指代实体的指针，而其是一个指针常量
例如:int intArray[10]; intArray++;编译出错，
虽然数组名可以转换为指向其指代实体的指针，但是它能被看作一个指针常量，不能被修改；而指针，不管指向结构体、数组还是基本数据类型的指针，都不包含原始数据结构的内涵。
3)指向数组的指针则是另外一种变量类型，仅仅意味着数组的存放地址。

3、数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅只是一个指针；失去了其常量特性，可以自增、自减等操作。

4、联合体union的存放顺序是所有成员都从低地址开始存放的，可以利用该特性来判断大端还是小端模式。

			C/C++程序员应聘常见面试题深入剖析
1、找错题
1)strcpy函数
(1)试题1：
void test1()
{
 char string[10];
 char *str1 = "0123456789";
 strcpy(string,str1);
}
字符串str1需要11个字节才能放下(包括末尾的'\0')，而string只有10个字节的空间，strcpy会导致数组越界
(2)试题2：
void test2()
{
 char string[10],str1[10];
 int i;
 for(i=0; i<10; i++)
 {
  str1[i] = 'a';
 }
 strcpy(string,str1);
}
strcpy字符串的拷贝以'\0'为结束符，str1没有'\0'则不能在数组内结束，strcpy调用使得从str1内存其复制到string内存起所复制的字节数具有不确定性。
(3)试题3:
void test3(char *str1)
{
 char string[10];
 if(strlen(str1) <= 10)
 {
  strcpy(string,str1);
 }
}
strlen的结果未统计'\0'，if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)

剖析：
A、字符串以'\0'结尾
B、对数组越界把握的敏感度
C、库函数strcpy的工作方式
(4)库函数strcpy的编写
char *strcpy(char *strDest, const char *strSrc)
//将源字符串加const,表明其为输入参数
{
 assert((strDest != NULL) && (strSrc != NULL));
//对源地址和目的地址加非0断言
 char *address = strDest;
 while((*strDest++ = *strSrc++) != '\0');
 return address;
//为了实现链式操作，将目的地址返回
}
(5)对strlen的掌握，它没有包括字符串末尾'\0'
int strlen(const char *str)
{
 assert(str != NULL);
 int len = 0;
 while((*str++) != '\0')
 {
   len++;
 }
 return len;
}

2)申请内存
(1)试题4:
void GetMemory(char *p)
{
 p = (char *)malloc(100);
}
void Test(void)
{
 char *str = NULL;
 GetMemory(str);
 strcpy(str, "hello world");
 printf(str);
}
传入GetMemory(char *p)函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值。
(2)试题5
char *GetMemory(void)
{
 char p[] = "hello world";
 return p;
}
void Test(void)
{
 char *str = NULL;
 str = GetMemory();
 printf(str);
}
 p[]数组为函数内的局部自动变量，在函数返回后，内存已经释放。
(3)试题6
void GetMemory(char **p, int num)
{
 *p = (char *)malloc(num);
}
void Test(void)
{
 char *str = NULL;
 GetMemory(&str, 100);
 strcpy(str, "hello");
 printf(str);
}
传入GetMemory(char *p)函数的形参为字符串指针的指针，可以成功，但是未判断内存是否申请成功，应加上
if(*p == NULL)
{
 //申请失败处理
}
同时未对malloc的内存进行释放
(4)试题7
void Test(void)
{
 char *str = (char *)malloc(100);
 strcpy(str, "hello");
 free(str);
 ...//省略其他语句
}
未判断内存是否申请成功，在free(str)后未置str为空，导致可能变成一个'野'指针

剖析：
A、指针的理解
B、变量的生存期及作用范围
C、良好的动态内存申请和释放习惯

指出错误
swap(int *p1, int *p2)
{
 int *p;
 *p = *p1;
 *p1 = *p2;
 *p2 = *p;
}
p为一个"野"指针，有可能指向系统区，导致程序运行的崩溃，改正：
swap(int *p1, int *p2)
{
 int p;
 p = *p1;
 *p1 = *p2;
 *p2 = p;
}

2、内功题
1)试题1：
问题：分别各处BOOL,int,float,指针变量与"0值"比较的if语句(假设变量名为var)
答案：BOOL型变量: if(!var)
int型变量: if(var == 0)
float型变量：
const float EPSINON = 0.00001;
if((var >= -EPSINON ) && (var <= EPSINON ))
指针变量: if(var == NULL)
2)试题2：
问题：一下为Windows NT下的32位C++程序，请计算sizeof的值
答案：void Func(char str[100])
{
 sizeof(str) = ?;
}
void *p = malloc(100);
sizeof(p) = ?;
结果都为4，即指针长度。
3)试题3：
问题：编写一个函数，作用是一个char组成的字符串循环右移n个，比如原来是"abcdefghi",如果n=2,移动后应该是"hiabcdefh"
答案1：
void LoopMove(char *pStr, int steps)
{
 char tmp[MAX_LEN];
 int n = strlen(pStr) - steps;
 strcpy(tmp, pStr + n);
 strcpy(tmp + steps, pStr);
 *(tmp + strlen(pStr)) = '\0';
 strcpy(pStr, tmp);
}
答案2：
void LoopMove(char *pStr, int steps)
{
 char tmp[MAX_LEN];
 int n = strlen(pStr) - steps;
 memcpy(tmp, pStr +n, steps);
 memcpy(pStr+steps, pStr, n);
 memcpy(pStr, tmp, steps);
}
剖析：最被频繁使用的库函数strcpy\memcpy\memset
4)试题4：
请说出static和const关键字尽可能多的作用
(1)static：A、函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值
B、在模块内static全局变量可以被模块内所用函数访问，但不能被模块外其他函数访问
C、在模块内static函数只可以被模块内其他函数调用，但不能被模块外其他函数访问
D、在类中的static成员变量属于整个类所有，对类的所有对象只有一份拷贝
E、在类中的static成员函数属于整个类所有，这个函数不接收this指针，因而只能访问类的static成员变量
(2)const:A、欲阻止一个变量被改变，可以使用const关键字，通常在定义时，对其初始化，以后就没机会修改
B、对于指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或两者同时指定为const。
C、在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值

3、技巧题
1)请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1
解答：
int checkCPU()
{
 {
  union w
  {
    int a;
    char b;
  }c;
  c.a = 1;
  return (c.b == 1);
 }
}
联合体union的存放顺序是所有成员都从低地址开始存放。假设a从地址0x10开始存放
0x10  0x11  0x12  0x13  a
0x10                    b
若小端存放，则c.b = 1
0x10  0x11  0x12  0x13  a
  1    0     0     0
0x10                    b 
  1
若大端存放，则c.b = 0
0x10  0x11  0x12  0x13  a
  0    0     0     1
0x10                    b 
  0

			一道著名外企面试题的抽丝剥茧

对于一个字节(8bit)的数据，求其中"1"的个数，要求算法的执行效率尽可能的高。
方法1：使用除、余的方法，效率最低;关键代码：
for(i=0; i<8; i++)
{
 if(a%2 == 1)
 {
  num++;
 }
 a = a/2;
}
方法2：使用位操作；关键代码
for(i=0; i<8; i++)
{
 num += (a>>i) &0x01;
}
或者
for(i=0; i<8; i++)
{
 if((a>>i)&0x01)
 num++;
}
方法3：使用分支操作，将255个数全部计算出来，效率可能比方法2要低；关键代码：
switch(a)
{
 case 0x0:
   num = 0;
 break;
 case 0x01:
 case 0x02:
 case 0x04:
  ...
 case 0x80:
   num = 1;
 break;
 .....
}
方法4：使用查表方法，将所有数全部计算出来，效率最高；关键代码：
BYTE numTable[256]=
{0,1,1,2,1....
 ...
};

			C/C++结构体的一个高级特性--指定成员的位数

1、结构体的高级特性，在基本成员变量的后面添加":数据位数"。
(1)struct ***
{
	成员1类型成员1：成员1位数；
	成员2类型成员2：成员2位数；
}
访问方法和没有拆分的方法一样
(2)例如
struct student
{
 unsigned int sex:1
 unsigned int age:15
};	两个成员加起来只占用了一个unsigend int的空间
访问：struct student sweek; sweek.sex=MALE; sweek.age = 20;
(3)不合理定义
struct student
{
 unsigned int sex:1;
 unsigned int age:12;
}; 两个成员加起来不是字节的整数倍。

2、CPU大小端模式
    在拆分基本成员变量的情况下，特别注意数据的存放顺序，与CPU的大小端有关。Big endian认为第一个字节为最高位字节(按照从低地址到高地址的顺序存放数据的高位字节到低位字节);Little endian认为第一个字节是最低字节(按照从低地址到高地址的顺序存放数据的低位字节到高位字节)。
例子：
struct Date
{
 char month:4;
 char date:4;
};
在大端模式下，第一字节低4位为date,第一字节高4位为month;在小端模式下，第一字节低4位为month，第一字节高4位为date。

3、注意事项
1)拆分的位数要符合逻辑，应仍然可以组合为基本成员变量
2)注意CPU的大端和小端模式(CPU存放数据的两种不同顺序)。

			C/C++中的近指令、远指针和巨指针
1、例子
char near *p;  //近指针
char far *p;   //远指针
char huge *p;  //巨指针

2、在16位处理器环境下，如果访问本段地址的值，用一个16位的指针(表示段内偏移)就可以访问到，而要访问本段以外地址的值，则需要用16位的段内偏移+16位的段地址，总共32位的指针。

3、区别
(1)近指针只能访问本段、只包含本段偏移的、位宽为16位的指针，只能对64K字节数据段内的地址进行存取；
例如：
char near *p;
p=(char near *)0xffff;(2)远指针能访问非本段、包含段偏移和段地址的、位宽为32位的指针，可以访问整个内存的地址。
(3)巨指针也是32位的指针，指针也表示16位段：16位偏移，也可以寻址任何地址，与远指针的区别在于进行了规格化处理。
这三类指针是段寻址的16bit处理器的产物。

				C/C++中联合体的使用
1、大端模式：按照从低地址到高地址的顺序存放数据的高位字节到低位字节；
小端模式：按照从低地址到高地址的顺序存放数据的低位字节到高位字节。
通过union来判断大端还是小端是个好的方法。

2、当多个基本类型或复合数据结构要占用同一片内存时，使用联合体；当多种类型，多个对象，多个事物只取其一时，选用联合体。




