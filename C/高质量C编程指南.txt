				第1章 文件结构
1、版权和版本的声明
一般位于头文件和定义文件的开头，可自行增减，主要内容：
(1)版权信息
(2)文件名称、标示符、摘要
(3)当前版本号，作者/修改者，完成日期
(4)版本历史信息

2、头文件的结构
(1)头文件开头处的版权和版本声明
(2)预处理块
(3)函数和类结构声明等
规则1:为了防止头文件被重复引用，应该用#ifndef/#define/#endif结构产生预处理模块
规则2:用#include<filename.h>格式引用标准库的头文件(从标准库目录开始搜索)
规则3:用#include"filename.h"格式来引用非标准库的头文件(将从用户的工作目录开始搜索)
建议:不要在头文件里"定义"，只存放"声明"
建议:不提倡使用全局变量，尽量不要在头文件中出现像extern int value 这类声明
3、源文件的结构
(1)定义文件开头处的版权和版本声明
(2)对一些头文件的引用
(3)程序的实现体(包括数据和代码)
4、头文件的作用
(1)通过头文件来调用库功能，用户只需按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现。
(2)头文件能加强类型安全检查，如果接口被使用，其方式与头文件中的声明不一致，编译器就会指出错误，大大减轻程序员调试、改错。

				第2章 程序的板式
1、空行
规则1:在每个类声明之后，每个函数定义结束之后都要加空行
规则2:在一个函数体内，逻辑上密切相关的语句之间不加空行，其他地方应加空行分隔。
2、代码行
规则1:一行代码只做一件事情，如只定义一个变量，或只写一条语句。
规则2:if,for,while,do等语句自占一行，执行语句不得紧跟其后。不论执行语句多少都要加{}，可以防止书写失误。
建议1:尽可能在定义变量的同时初始化该变量。如果引用了未被初始化的变量，可能会导致程序错误，本建议减少隐患。
3、代码行内的空格
(1)规则
规则1:关键字之后要留空格。
规则2:函数名之后不要留空格，紧跟左括号'('，以与关键字区别
规则3:'('向后紧跟，')'、','、'；'向前紧跟，紧跟处不留空格
规则4:','之后要留空格
规则5:赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符等二元操作符的前后应当加空格
规则6:一元操作符前后不加空格
规则7:像"[]"、"."、"->"这类操作符前后不加空格
(2)建议
建议1:对于表达式比较长的for语句和if语句，为了紧凑起见可以适当的去掉一些空格
4、对齐
(1)规则
规则1:程序的分界符'{'和'}'应独占一行并且位于同一列，同时与引用它们的语句左对齐
规则2:{}之内的代码块在'{'右边数格左对齐
5、长行拆分
规则1:长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首
6、注释
规则1:编写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。、


				第4章 表达式和基本语句
1、if语句
(1)布尔变量与零值比较
不可将布尔变量直接与TRUE、FALSE或者1、0进行比较，而应如下：if(flag)表示真，if(!flag)表示假
(2)整型变量与零值比较
应当将整型变量用"=="或"!="直接与0比较
(3)浮点变量与零值比较
不可将浮点变量用"=="或"!="直接与任何数字比较，存在精度限制，应该设法转换成">="活"<="形式
例:if((x>=-EPSIION)&&(x<=EPSION))其中EPSION是允许的误差
(4)指针变量与零值比较
应当将指针变量用"=="或"!="与NULL比较
(5)if语句补充说明
if(NULL == P)而不是if(p == NULL)这样可以防止if(p == NULL)误写成 if(p = NULL)。
2、循环语句的效率
(1)在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环层放在最外面，以减少CPU跨切循环层的次数
(2)如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。
3、for语句的循环控制变量
(1)不可在for循环体内修改循环变量，防止for循环失去控制
(2)建议for语句的循环控制变量的取值采用"半开闭区间"写法
4、switch语句
(1)每个case语句的结尾不要忘了加break，否则将导致多个分支重叠(除非有意使多个分支重叠)
(2)不要忘记最后那个default分支，即使程序真的不需要default处理，也应该保留语句default:break

				第6章 函数设计
1、参数规则
(1)参数的书写要完整，不要贪图省事只写参数的类型而省略参数名字
(2)参数命名要恰当，顺序要合理
(3)如果参数是指针，且仅作输入用，则应在类型前加const，以防止该指针指向的数据在函数内被意外修改。
例:void StringCopy(char *strDest,const char *strSource)
(4)避免函数有太多的参数，参数个数尽量控制在5个以内。如果参数太多，在使用时容易将参数类型或顺序搞错
2、返回值规则
(1)不要省略返回值的类型。在C语言中，凡不加类型说明的函数，一律自动按整型处理，容易被误解为viod类型。
(2)getchar的返回值不是char类型，而是int类型，其原型如下：int getchar(void)
3、函数内部实现的规则
(1)在函数体的"入口处"，对参数的有效性进行检查
(2)在函数体的"出口处"，对return语句的正确性和效率进行检查
A.return语句不可返回指向"栈内存"的指针或者引用，因为该内存在函数体结束时被自动销毁。
B.要搞清楚返回的究竟是"值"\"指针"\"引用"
C.如果函数返回值是一个对象，要考虑return语句的效率。
return int(x+y) 效率高于 int temp=x+y; return temp;
(3)建议：函数功能要单一，不要设计多用途的函数，尽量控制在50行代码之内，尽量避免函数带有"记忆"功能(尽量少用static局部变量)
4、使用断言(assert)
程序一般分为Debug版本和Release版本，Debug版本用于内部调试，Release版本发行给用户使用。assert是仅在Debug版本起作用的宏，用于检查不应该发生的情况。

				第7章 内存管理
1、内存分配方式
(1)从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，例如全局变量，static变量
(2)在栈上分配。执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数结束时这些存储单元自动被释放。
(3)从堆上分配，亦称动态内存分配。程序在运行时用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存
2、常见的内存错误及其对策
(1)内存分配未成功，却是用了它：使用之前先检查指针是否为NULL
(2)内存分配虽成功，但是尚未初始化就引用它
(3)内存分配成功并且已经初始化，但是操作越过了内存的边界
(4)忘记了释放内存，造成内存泄露
3、指针与数组的对比
    数组要么在静态存储区被创建(如全局数组)，要么在栈上被创建。数组名对应着一块内存，其地址和容量在生命期内保持不变，只有数组的内容可以改变。
    指针可以随时指向任意类型的内存块，它的特征是"可变"，常用指针来操作内存。
4、杜绝"野指针"
"野指针"不是NULL指针，是指向"垃圾"内存的指针。成因：一是指针变量没有被初始化，二是指针p被free或delete之后，没有置NULL，让人误以为p是个合法的指针。
5、malloc/free的使用要点
(1)函数malloc的原型如下:void *malloc(size_t size)
例子：int *p = (int *)malloc(sizeof(int) * length),应该把注意力集中在两个要素上:"类型转换"和"sizeof"
可以使用sizeof来求不同编译器下类型的字节数。

			第11章 其他变成经验
1、使用const提高函数的健壮性
(1)用const修饰函数的参数
A.如果参数作输出用，不能用const修饰，否则该参数将失去输出功能，它只能修饰输入参数
B.如果输入参数采用"指针传递"，那么加const修饰可以防止意外的改动该指针内容。
C.如果输入参数采用"值传递"，由于函数将自动产生临时变量用于复制该参数，所以该输入参数无需保护，不要加const修饰。例子:不要将void func(int x)写成void func(const int x)。
2、提高程序的效率
(1)提高程序的全局效率为主，提高局部效率为辅
(2)在优化程序的效率时，应当先找出限制效率的"瓶颈"
(3)先优化数据结构和算法，再优化执行代码
(4)不要追求紧凑的代码，因为紧凑的代码并不能产生高效的机器码

